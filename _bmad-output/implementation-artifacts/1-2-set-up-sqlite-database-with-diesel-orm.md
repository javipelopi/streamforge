# Story 1.2: Set Up SQLite Database with Diesel ORM

Status: ready-for-dev

## Story

As a developer,
I want a SQLite database with Diesel ORM configured,
So that the application can persist data locally with compile-time query safety.

## Acceptance Criteria

1. **Given** the Tauri project from Story 1.1
   **When** I set up Diesel with SQLite
   **Then** the following is configured:
   - Diesel CLI installed and configured
   - SQLite database file location in app data directory
   - `diesel.toml` configuration
   - Initial migration creating `settings` table for app configuration
   **And** migrations can be run automatically on app startup
   **And** the database file persists across app restarts

## Tasks / Subtasks

- [ ] Task 1: Install and configure Diesel CLI for SQLite (AC: #1)
  - [ ] 1.1 Install Diesel CLI with sqlite-bundled feature: `cargo install diesel_cli --no-default-features --features sqlite-bundled`
  - [ ] 1.2 Verify Diesel CLI version matches 2.2.x

- [ ] Task 2: Add Diesel dependencies to Cargo.toml (AC: #1)
  - [ ] 2.1 Add `diesel` with sqlite and returning_clauses_for_sqlite_3_35 features
  - [ ] 2.2 Add `diesel_migrations` for embedded migrations
  - [ ] 2.3 Add `dotenvy` for environment configuration (development)
  - [ ] 2.4 Verify all dependencies compile with `cargo check`

- [ ] Task 3: Initialize Diesel configuration (AC: #1)
  - [ ] 3.1 Create `.env` file with DATABASE_URL pointing to `test.db` for development
  - [ ] 3.2 Run `diesel setup` to create diesel.toml and migrations directory
  - [ ] 3.3 Configure diesel.toml to generate schema in `src/db/schema.rs`
  - [ ] 3.4 Add `.env` to `.gitignore` (keep `.env.example` for reference)

- [ ] Task 4: Create initial settings migration (AC: #1)
  - [ ] 4.1 Generate migration: `diesel migration generate create_settings`
  - [ ] 4.2 Write up.sql to create settings table with key-value structure
  - [ ] 4.3 Write down.sql to drop settings table
  - [ ] 4.4 Run `diesel migration run` to verify migration works
  - [ ] 4.5 Run `diesel migration redo` to verify rollback works

- [ ] Task 5: Create database module structure (AC: #1)
  - [ ] 5.1 Create `src-tauri/src/db/mod.rs` module
  - [ ] 5.2 Create `src-tauri/src/db/schema.rs` (generated by Diesel)
  - [ ] 5.3 Create `src-tauri/src/db/models.rs` for Setting struct
  - [ ] 5.4 Create `src-tauri/src/db/connection.rs` for connection management
  - [ ] 5.5 Export db module from `src-tauri/src/lib.rs`

- [ ] Task 6: Implement app data directory database path (AC: #1)
  - [ ] 6.1 Use Tauri's `app.path()` API to get app_data_dir
  - [ ] 6.2 Construct database path as `{app_data_dir}/iptv.db`
  - [ ] 6.3 Create parent directories if they don't exist
  - [ ] 6.4 Store database path resolution logic in connection module

- [ ] Task 7: Implement embedded migrations for runtime execution (AC: #1)
  - [ ] 7.1 Use `embed_migrations!` macro to bundle migrations in binary
  - [ ] 7.2 Create `run_migrations` function using MigrationHarness trait
  - [ ] 7.3 Add build.rs to trigger recompile on migration changes
  - [ ] 7.4 Call migrations during Tauri setup hook

- [ ] Task 8: Integrate database initialization with Tauri app (AC: #1)
  - [ ] 8.1 Initialize database connection in Tauri's `setup` hook
  - [ ] 8.2 Run pending migrations automatically on app startup
  - [ ] 8.3 Store connection pool/state for use by Tauri commands
  - [ ] 8.4 Add basic error handling for database initialization failures

- [ ] Task 9: Verify persistence across restarts (AC: #1)
  - [ ] 9.1 Add a test Tauri command to insert a setting
  - [ ] 9.2 Add a test Tauri command to read settings
  - [ ] 9.3 Verify data persists after app restart
  - [ ] 9.4 Clean up test commands (or mark for removal in future story)

- [ ] Task 10: Build and verification (AC: #1)
  - [ ] 10.1 Run `cargo check` to verify Rust compilation
  - [ ] 10.2 Run `pnpm tauri dev` and verify database is created
  - [ ] 10.3 Verify database file exists in correct app data location
  - [ ] 10.4 Run `pnpm tauri build` and verify production build works

## Dev Notes

### Architecture Compliance

This story implements the database layer specified in the Architecture document:
- **Database**: SQLite + Diesel ORM
- **Location**: App data directory (platform-specific)
- **Migrations**: Diesel migrations with embedded runtime execution
- **Initial Schema**: settings table (key-value store)

[Source: architecture.md#Technology Stack]
[Source: architecture.md#Data Architecture]

### Critical Technical Requirements

**Diesel 2.2.x Setup:**
- Requires Rust 1.86.0+ (verify with `rustup update stable`)
- Use `sqlite-bundled` feature for static linking (avoids system SQLite dependency)
- Enable `returning_clauses_for_sqlite_3_35` for RETURNING clause support
- Use `diesel_migrations` crate with `embed_migrations!` for binary-embedded migrations

**Cargo.toml Dependencies:**
```toml
[dependencies]
diesel = { version = "2.2.0", features = ["sqlite", "returning_clauses_for_sqlite_3_35"] }
diesel_migrations = "2.2.0"
dotenvy = "0.15"
```

**diesel.toml Configuration:**
```toml
[print_schema]
file = "src/db/schema.rs"
custom_type_derives = ["diesel::query_builder::QueryId"]

[migrations_directory]
dir = "migrations"
```

### Settings Table Schema

```sql
-- up.sql
CREATE TABLE settings (
    key TEXT PRIMARY KEY NOT NULL,
    value TEXT NOT NULL
);

-- Insert default settings
INSERT INTO settings (key, value) VALUES ('server_port', '5004');
INSERT INTO settings (key, value) VALUES ('auto_start', 'false');
```

```sql
-- down.sql
DROP TABLE settings;
```

### Database Path Resolution

Use Tauri 2.0's path API to get platform-appropriate app data directory:

```rust
use tauri::Manager;

fn get_db_path(app: &tauri::App) -> Result<PathBuf, Box<dyn std::error::Error>> {
    let app_data_dir = app.path().app_data_dir()?;
    std::fs::create_dir_all(&app_data_dir)?;
    Ok(app_data_dir.join("iptv.db"))
}
```

**Platform-specific paths:**
- **Windows**: `C:\Users\{user}\AppData\Roaming\com.iptv.app\iptv.db`
- **macOS**: `~/Library/Application Support/com.iptv.app/iptv.db`
- **Linux**: `~/.local/share/com.iptv.app/iptv.db`

### Embedded Migrations Pattern

```rust
use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
use diesel::sqlite::SqliteConnection;

pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("migrations");

pub fn run_migrations(conn: &mut SqliteConnection) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    conn.run_pending_migrations(MIGRATIONS)?;
    Ok(())
}
```

**build.rs for migration recompilation:**
```rust
fn main() {
    tauri_build::build();
    println!("cargo:rerun-if-changed=migrations");
}
```

### Database Connection Establishment

```rust
use diesel::prelude::*;
use diesel::sqlite::SqliteConnection;

pub fn establish_connection(database_url: &str) -> Result<SqliteConnection, ConnectionError> {
    SqliteConnection::establish(database_url)
}
```

### Tauri Integration

Initialize in `setup` hook for access to app handle:

```rust
fn main() {
    tauri::Builder::default()
        .setup(|app| {
            let db_path = get_db_path(app)?;
            let database_url = db_path.to_string_lossy().to_string();

            let mut conn = establish_connection(&database_url)?;
            run_migrations(&mut conn)?;

            // Store connection for later use by commands
            app.manage(DbConnection::new(database_url));

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![/* commands */])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### Project Structure After This Story

```
src-tauri/
├── Cargo.toml              # Updated with Diesel dependencies
├── diesel.toml             # NEW: Diesel configuration
├── build.rs                # Updated: migration recompile trigger
├── migrations/             # NEW: Diesel migrations directory
│   └── 00000000000000_create_settings/
│       ├── up.sql
│       └── down.sql
├── src/
│   ├── main.rs             # Updated: setup hook with db init
│   ├── lib.rs              # Updated: export db module
│   ├── commands/
│   │   └── mod.rs
│   └── db/                 # NEW: Database module
│       ├── mod.rs
│       ├── schema.rs       # Generated by Diesel
│       ├── models.rs       # Setting struct
│       └── connection.rs   # Connection management
```

### Previous Story Intelligence

**From Story 1-1 Implementation:**
- Project uses pnpm as package manager
- Rust backend is in `src-tauri/` directory
- Commands module exists at `src-tauri/src/commands/mod.rs`
- App identifier is `com.iptv.app`
- Build verification: use `pnpm tauri dev` and `pnpm tauri build`
- ESM compatibility is set up correctly
- Tailwind CSS v4 with @tailwindcss/vite plugin configured

**Learnings Applied:**
- Use `cargo check` before attempting builds to catch errors early
- Icon format issues were resolved (RGBA PNG required)
- Cross-shell compatibility handled for cargo paths

### Git Intelligence

Recent commits show clean implementation pattern:
- `f838f89` - Code review fixes (ESLint, error handling, accessibility)
- `be70533` - Core implementation commit
- Follow the same pattern: implement first, then address review

### Testing Notes

- No ATDD tests specified for this story in the tests folder
- Manual verification through Tauri commands is acceptable
- Future stories will add comprehensive database tests
- Consider adding cargo test for db module functions

### References

- [Source: architecture.md#Database Schema (SQLite)] - Full schema definition
- [Source: architecture.md#Project Structure] - Directory layout with db module
- [Source: architecture.md#Technology Stack] - SQLite + Diesel ORM decision
- [Source: epics.md#Story 1.2] - Original acceptance criteria
- [Source: prd.md#Data Storage] - Local storage requirements

### Latest Technical Information (2026)

**Diesel ORM 2.2.x:**
- Current stable: v2.2.0 (use this version)
- Requires Rust 1.86.0+
- SQLite 3.35.0+ required for RETURNING clause support
- Use `sqlite-bundled` feature for static linking
- [Diesel Getting Started Guide](https://diesel.rs/guides/getting-started)
- [Diesel Migrations Docs](https://docs.rs/diesel_migrations/2.2.0/diesel_migrations/macro.embed_migrations.html)

**Tauri 2.0 Path API:**
- Use `app.path().app_data_dir()` to get platform-specific data directory
- Available in setup hook via app handle
- Creates path: `{app_data}/com.iptv.app/`
- [Tauri SQL Plugin Reference](https://v2.tauri.app/plugin/sql/)

**Environment Setup:**
- Install CLI: `cargo install diesel_cli --no-default-features --features sqlite-bundled`
- Create `.env` with `DATABASE_URL=test.db` for development
- Run `diesel setup` to initialize

## Dev Agent Record

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes List

### File List

