# ATDD Checklist - Epic 1, Story 1.2: Set Up SQLite Database with Diesel ORM

**Date:** 2026-01-19
**Author:** Javier
**Primary Test Level:** Integration (Backend/Database)

---

## Story Summary

As a developer, I want a SQLite database with Diesel ORM configured, so that the application can persist data locally with compile-time query safety.

**As a** developer
**I want** a SQLite database with Diesel ORM configured
**So that** the application can persist data locally with compile-time query safety

---

## Acceptance Criteria

1. **Given** the Tauri project from Story 1.1
   **When** I set up Diesel with SQLite
   **Then** the following is configured:
   - Diesel CLI installed and configured
   - SQLite database file location in app data directory
   - `diesel.toml` configuration
   - Initial migration creating `settings` table for app configuration
   **And** migrations can be run automatically on app startup
   **And** the database file persists across app restarts

---

## Failing Tests Created (RED Phase)

### Integration Tests (17 tests)

**File:** `tests/integration/database-setup.spec.ts` (316 lines)

All tests are currently FAILING as expected in the RED phase:

- ✅ **Test:** should have Diesel CLI installed with SQLite support
  - **Status:** RED - `diesel: command not found`
  - **Verifies:** Diesel CLI 2.2.x is installed with sqlite-bundled feature

- ✅ **Test:** should have diesel.toml configuration file
  - **Status:** RED - File does not exist
  - **Verifies:** diesel.toml exists and points to src/db/schema.rs

- ✅ **Test:** should have Diesel dependencies in Cargo.toml
  - **Status:** RED - Dependencies not present
  - **Verifies:** diesel, diesel_migrations, and dotenvy are in Cargo.toml

- ✅ **Test:** should have migrations directory with settings migration
  - **Status:** RED - Directory does not exist
  - **Verifies:** migrations/ directory exists with create_settings migration

- ✅ **Test:** should have valid up.sql creating settings table
  - **Status:** RED - Migration file does not exist
  - **Verifies:** up.sql creates settings table with key/value columns

- ✅ **Test:** should have valid down.sql dropping settings table
  - **Status:** RED - Migration file does not exist
  - **Verifies:** down.sql properly drops settings table

- ✅ **Test:** should have database module structure in src/db
  - **Status:** RED - Directory does not exist
  - **Verifies:** src/db/ directory with mod.rs, schema.rs, models.rs, connection.rs

- ✅ **Test:** should have db module exported from lib.rs
  - **Status:** RED - Module not exported
  - **Verifies:** `pub mod db;` is in src/lib.rs

- ✅ **Test:** should have Setting model struct defined
  - **Status:** RED - File does not exist
  - **Verifies:** Setting struct with Queryable and Insertable derives

- ✅ **Test:** should have database path resolution in connection module
  - **Status:** RED - File does not exist
  - **Verifies:** Uses Tauri's app_data_dir() API for database path

- ✅ **Test:** should have embedded migrations macro in connection module
  - **Status:** RED - File does not exist
  - **Verifies:** embed_migrations!() and run_pending_migrations() are implemented

- ✅ **Test:** should have build.rs configured to watch migrations
  - **Status:** RED - build.rs does not watch migrations
  - **Verifies:** cargo:rerun-if-changed=migrations in build.rs

- ✅ **Test:** should initialize database in Tauri setup hook
  - **Status:** RED - Setup hook not modified
  - **Verifies:** Database initialization in .setup() closure

- ✅ **Test:** should run migrations automatically on startup
  - **Status:** RED - Migration code not in setup
  - **Verifies:** run_pending_migrations() called on app startup

- ✅ **Test:** should have test commands for verifying persistence
  - **Status:** RED - Commands not implemented
  - **Verifies:** set_setting/get_setting commands exist

- ✅ **Test:** should compile Rust backend with Diesel dependencies
  - **Status:** GREEN (passes) - Expected to fail after adding Diesel
  - **Verifies:** cargo check passes with all Diesel dependencies

- ✅ **Test:** should have generated schema.rs matching settings table
  - **Status:** RED - File does not exist
  - **Verifies:** schema.rs generated by Diesel contains settings table definition

---

## Data Factories Created

### Setting Factory

**File:** `tests/support/factories/setting.factory.ts` (66 lines)

**Exports:**

- `createSetting(overrides?)` - Create single Setting with optional overrides using faker
- `createSettings(count)` - Create array of Settings
- `createDefaultSettings()` - Create default app settings (server_port, auto_start)

**Example Usage:**

```typescript
import { createSetting, createDefaultSettings } from '../support/factories/setting.factory';

// Random setting (unique key via faker)
const setting = createSetting();

// Specific setting
const serverPort = createSetting({ key: 'server_port', value: '5004' });

// Default settings
const defaults = createDefaultSettings();
```

**Note:** This factory follows the data-factories.md pattern:
- Uses `@faker-js/faker` for unique keys (prevents parallel test collisions)
- Supports Partial<T> overrides for specific test scenarios
- Generates complete valid objects with sensible defaults

---

## Fixtures Created

**None required for this story.**

This story focuses on database infrastructure setup. Fixtures will be added in future stories when E2E tests require authenticated database state or complex test scenarios.

For now, integration tests verify file structure and configuration without runtime fixtures.

---

## Mock Requirements

**None required for this story.**

This story implements real SQLite database functionality. No external services need mocking.

The database is tested using:
- File system verification (migrations, configuration files)
- Rust compilation checks (cargo check)
- Static code analysis (checking for required imports/macros)

Runtime database tests will be added in future stories when implementing actual database operations.

---

## Required data-testid Attributes

**Not applicable for this story.**

This is a backend/database infrastructure story with no UI components. No data-testid attributes are needed.

---

## Implementation Checklist

### Test: should have Diesel CLI installed with SQLite support

**File:** `tests/integration/database-setup.spec.ts:25`

**Tasks to make this test pass:**

- [ ] Install Diesel CLI: `cargo install diesel_cli --no-default-features --features sqlite-bundled`
- [ ] Verify installation: `diesel --version` shows 2.2.x
- [ ] Add diesel CLI to PATH if necessary
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have Diesel CLI"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.25 hours

---

### Test: should have diesel.toml configuration file

**File:** `tests/integration/database-setup.spec.ts:41`

**Tasks to make this test pass:**

- [ ] Create `.env` file in src-tauri/ with `DATABASE_URL=test.db`
- [ ] Run `diesel setup` in src-tauri/ directory
- [ ] Verify diesel.toml is created
- [ ] Configure diesel.toml to set `file = "src/db/schema.rs"`
- [ ] Add `.env` to .gitignore (create .env.example for reference)
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have diesel.toml"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.25 hours

---

### Test: should have Diesel dependencies in Cargo.toml

**File:** `tests/integration/database-setup.spec.ts:57`

**Tasks to make this test pass:**

- [ ] Add to Cargo.toml dependencies:
  ```toml
  diesel = { version = "2.2.0", features = ["sqlite", "returning_clauses_for_sqlite_3_35"] }
  diesel_migrations = "2.2.0"
  dotenvy = "0.15"
  ```
- [ ] Run `cargo check` to verify dependencies resolve
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have Diesel dependencies"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.25 hours

---

### Test: should have migrations directory with settings migration

**File:** `tests/integration/database-setup.spec.ts:78`

**Tasks to make this test pass:**

- [ ] Generate migration: `diesel migration generate create_settings`
- [ ] Verify migrations/ directory is created with timestamped subdirectory
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have migrations directory"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.1 hours

---

### Test: should have valid up.sql creating settings table

**File:** `tests/integration/database-setup.spec.ts:98`

**Tasks to make this test pass:**

- [ ] Edit migrations/.../up.sql with:
  ```sql
  CREATE TABLE settings (
      key TEXT PRIMARY KEY NOT NULL,
      value TEXT NOT NULL
  );

  INSERT INTO settings (key, value) VALUES ('server_port', '5004');
  INSERT INTO settings (key, value) VALUES ('auto_start', 'false');
  ```
- [ ] Run `diesel migration run` to test migration
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have valid up.sql"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.25 hours

---

### Test: should have valid down.sql dropping settings table

**File:** `tests/integration/database-setup.spec.ts:124`

**Tasks to make this test pass:**

- [ ] Edit migrations/.../down.sql with: `DROP TABLE settings;`
- [ ] Run `diesel migration redo` to verify rollback works
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have valid down.sql"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.1 hours

---

### Test: should have database module structure in src/db

**File:** `tests/integration/database-setup.spec.ts:151`

**Tasks to make this test pass:**

- [ ] Create directory: `src-tauri/src/db/`
- [ ] Create empty files: mod.rs, schema.rs, models.rs, connection.rs
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have database module structure"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.1 hours

---

### Test: should have db module exported from lib.rs

**File:** `tests/integration/database-setup.spec.ts:166`

**Tasks to make this test pass:**

- [ ] Add `pub mod db;` to src-tauri/src/lib.rs
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have db module exported"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.05 hours

---

### Test: should have Setting model struct defined

**File:** `tests/integration/database-setup.spec.ts:175`

**Tasks to make this test pass:**

- [ ] Create models.rs with Setting struct:
  ```rust
  use diesel::prelude::*;

  #[derive(Queryable, Insertable, Debug)]
  #[diesel(table_name = crate::db::schema::settings)]
  pub struct Setting {
      pub key: String,
      pub value: String,
  }
  ```
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have Setting model"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.25 hours

---

### Test: should have database path resolution in connection module

**File:** `tests/integration/database-setup.spec.ts:192`

**Tasks to make this test pass:**

- [ ] Implement get_db_path() function in connection.rs using Tauri's app.path().app_data_dir()
- [ ] Add create_dir_all() to ensure parent directories exist
- [ ] Construct path as `{app_data_dir}/iptv.db`
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have database path resolution"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.5 hours

---

### Test: should have embedded migrations macro in connection module

**File:** `tests/integration/database-setup.spec.ts:207`

**Tasks to make this test pass:**

- [ ] Add to connection.rs:
  ```rust
  use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};

  pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("migrations");

  pub fn run_migrations(conn: &mut SqliteConnection) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
      conn.run_pending_migrations(MIGRATIONS)?;
      Ok(())
  }
  ```
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have embedded migrations"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.5 hours

---

### Test: should have build.rs configured to watch migrations

**File:** `tests/integration/database-setup.spec.ts:218`

**Tasks to make this test pass:**

- [ ] Add to build.rs: `println!("cargo:rerun-if-changed=migrations");`
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have build.rs configured"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.1 hours

---

### Test: should initialize database in Tauri setup hook

**File:** `tests/integration/database-setup.spec.ts:231`

**Tasks to make this test pass:**

- [ ] Modify main.rs .setup() closure to call database initialization functions
- [ ] Import db module functions
- [ ] Call establish_connection() and run_migrations()
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should initialize database"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.5 hours

---

### Test: should run migrations automatically on startup

**File:** `tests/integration/database-setup.spec.ts:246`

**Tasks to make this test pass:**

- [ ] Ensure run_pending_migrations() or run_migrations() is called in setup hook
- [ ] Handle errors appropriately (propagate to setup return)
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should run migrations automatically"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.25 hours (covered by previous task)

---

### Test: should have test commands for verifying persistence

**File:** `tests/integration/database-setup.spec.ts:260`

**Tasks to make this test pass:**

- [ ] Create set_setting and get_setting Tauri commands in commands/mod.rs
- [ ] Implement commands using Diesel query builders
- [ ] Register commands in main.rs invoke_handler
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have test commands"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 1.0 hours

---

### Test: should compile Rust backend with Diesel dependencies

**File:** `tests/integration/database-setup.spec.ts:277`

**Tasks to make this test pass:**

- [ ] After all implementation tasks, run `cargo check`
- [ ] Fix any compilation errors
- [ ] Ensure all imports and macros are correct
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should compile Rust"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.5 hours (debugging/fixing)

---

### Test: should have generated schema.rs matching settings table

**File:** `tests/integration/database-setup.spec.ts:301`

**Tasks to make this test pass:**

- [ ] Run `diesel migration run` to generate schema.rs
- [ ] Verify schema.rs contains settings table definition
- [ ] Run test: `pnpm exec playwright test tests/integration/database-setup.spec.ts -g "should have generated schema"`
- [ ] ✅ Test passes (green phase)

**Estimated Effort:** 0.1 hours (automatic generation)

---

## Running Tests

```bash
# Run all failing tests for this story
pnpm exec playwright test tests/integration/database-setup.spec.ts

# Run specific test
pnpm exec playwright test tests/integration/database-setup.spec.ts -g "Diesel CLI"

# Run tests in headed mode (not applicable for integration tests)
# Integration tests are file system checks, no browser needed

# Debug specific test
pnpm exec playwright test tests/integration/database-setup.spec.ts -g "Diesel dependencies" --debug

# Run with verbose output
pnpm exec playwright test tests/integration/database-setup.spec.ts --reporter=list
```

---

## Red-Green-Refactor Workflow

### RED Phase (Complete) ✅

**TEA Agent Responsibilities:**

- ✅ All 17 tests written and failing
- ✅ Setting data factory created with faker for unique data
- ✅ No fixtures required (file system verification tests)
- ✅ No mocks required (real SQLite database)
- ✅ No data-testid requirements (backend-only story)
- ✅ Implementation checklist created with 17 tasks

**Verification:**

- All tests run and fail as expected (16 RED, 1 GREEN baseline)
- Failure messages are clear: "command not found", "file does not exist", "dependencies not present"
- Tests fail due to missing implementation, not test bugs
- Initial test run output confirms RED phase

---

### GREEN Phase (DEV Team - Next Steps)

**DEV Agent Responsibilities:**

1. **Pick one failing test** from implementation checklist (start with Diesel CLI installation)
2. **Read the test** to understand expected behavior
3. **Implement minimal code** to make that specific test pass
4. **Run the test** to verify it now passes (green)
5. **Check off the task** in implementation checklist
6. **Move to next test** and repeat

**Key Principles:**

- One test at a time (sequential: CLI → config → dependencies → migrations → code)
- Minimal implementation (follow the story dev notes exactly)
- Run tests frequently (immediate feedback per test)
- Use implementation checklist as roadmap

**Recommended Test Order:**

1. Install Diesel CLI (enables all other tasks)
2. Add dependencies to Cargo.toml
3. Run diesel setup (creates diesel.toml)
4. Generate and write migration files
5. Create database module structure
6. Implement models, connection, and migrations
7. Integrate with Tauri setup hook
8. Add test commands
9. Verify compilation and schema generation

**Progress Tracking:**

- Check off tasks as you complete them in this document
- Run specific tests after each task: `pnpm exec playwright test ... -g "test name"`
- Share progress in daily standup
- Mark story as IN PROGRESS in sprint-status.yaml

---

### REFACTOR Phase (DEV Team - After All Tests Pass)

**DEV Agent Responsibilities:**

1. **Verify all tests pass** (green phase complete - all 17 tests passing)
2. **Review code for quality** (error handling, documentation, type safety)
3. **Extract duplications** (DRY principle - shared connection logic)
4. **Optimize if needed** (probably not needed for basic setup)
5. **Ensure tests still pass** after each refactor
6. **Update documentation** (README if database setup instructions needed)

**Key Principles:**

- Tests provide safety net (refactor with confidence)
- Make small refactors (easier to debug if tests fail)
- Run tests after each change: `pnpm exec playwright test tests/integration/database-setup.spec.ts`
- Don't change test behavior (only implementation)

**Potential Refactorings:**

- Extract database path resolution to reusable function
- Add comprehensive error handling with thiserror
- Add doc comments to public functions
- Consider connection pooling (if multiple commands need concurrent access)

**Completion:**

- All 17 tests pass (GREEN)
- Code quality meets team standards (ESLint, Clippy)
- No code smells or duplications
- Ready for code review and story approval

---

## Next Steps

1. **Share this checklist and failing tests** with the dev workflow (manual handoff)
2. **Review this checklist** in standup - estimated 4-5 hours total effort
3. **Run failing tests** to confirm RED phase: `pnpm exec playwright test tests/integration/database-setup.spec.ts`
4. **Begin implementation** using implementation checklist as guide (start with Diesel CLI installation)
5. **Work one test at a time** (red → green for each task)
6. **Share progress** in daily standup (number of tests passing)
7. **When all tests pass**, refactor code for quality (error handling, docs)
8. **When refactoring complete**, manually update story status to 'done' in sprint-status.yaml

---

## Knowledge Base References Applied

This ATDD workflow consulted the following knowledge fragments:

- **fixture-architecture.md** - Pure function → fixture patterns (not needed for this story, but loaded for future reference)
- **data-factories.md** - Factory patterns using `@faker-js/faker` for random test data generation with overrides support (applied in setting.factory.ts)
- **test-quality.md** - Test design principles (Given-When-Then comments, determinism, isolation, explicit assertions)
- **test-levels-framework.md** - Test level selection (Integration tests chosen for backend database verification)

See `_bmad/bmm/testarch/tea-index.csv` for complete knowledge fragment mapping.

---

## Test Execution Evidence

### Initial Test Run (RED Phase Verification)

**Command:** `pnpm exec playwright test tests/integration/database-setup.spec.ts --reporter=list`

**Results:**

```
Running 17 tests using 4 workers

  ✘  16 failing tests (as expected - missing implementation)
  ✓   1 passing test: "should compile Rust backend" (baseline - passes before Diesel added)

Total tests: 17
Passing: 1 (baseline)
Failing: 16 (expected)
Duration: ~2 seconds
Status: ✅ RED phase verified
```

**Expected Failure Messages:**

1. `diesel: command not found` - Diesel CLI not installed
2. `diesel.toml: file does not exist` - Configuration not created
3. `Cargo.toml: Expected substring "diesel"` - Dependencies not added
4. `migrations/: directory does not exist` - Migration not generated
5. `up.sql: file does not exist` - Migration files not written
6. `down.sql: file does not exist` - Rollback migration not written
7. `src/db/: directory does not exist` - Database module not created
8. `lib.rs: Expected "pub mod db"` - Module not exported
9. `models.rs: file does not exist` - Setting model not defined
10. `connection.rs: file does not exist` - Connection logic not implemented
11. `embed_migrations!: not found in connection.rs` - Embedded migrations not set up
12. `build.rs: Expected "cargo:rerun-if-changed=migrations"` - Build script not configured
13. `main.rs setup: db initialization not found` - Setup hook not modified
14. `run_pending_migrations: not found in main.rs` - Auto-migrations not implemented
15. `commands: no settings commands found` - Test commands not created
16. `schema.rs: file does not exist` - Schema not generated by Diesel

All failures are due to missing implementation (not test bugs). This confirms proper RED phase.

---

## Notes

### Test Strategy for This Story

This story uses **Integration tests (backend verification)** rather than E2E tests because:

1. **No UI involved** - This is pure backend database setup
2. **File system checks** - Tests verify configuration files, migrations, and code structure
3. **Compilation verification** - Tests use `cargo check` to ensure Rust compiles
4. **Static analysis** - Tests check for required imports, macros, and patterns

**Why not E2E tests?**
- E2E tests require running the full Tauri app with browser
- This story has no user-facing features to test
- Database functionality will be tested via E2E in future stories (when UI uses database)

**Future Testing:**
- Story 1.3+ will add E2E tests that use the database
- E2E tests will verify actual database operations (CRUD)
- E2E tests will confirm data persistence across app restarts

### Architecture Alignment

This ATDD workflow aligns with Architecture decisions:

- **Database**: SQLite with Diesel ORM (compile-time query safety)
- **Location**: App data directory (platform-specific via Tauri API)
- **Migrations**: Diesel migrations with embedded runtime execution
- **Schema**: settings table (key-value store for app configuration)

[Source: architecture.md#Data Architecture]
[Source: architecture.md#Technology Stack]

### Diesel 2.2.x Compatibility Notes

**Important:** This test suite assumes:
- Rust 1.86.0+ (verify with `rustup update stable`)
- Diesel 2.2.0 with sqlite-bundled feature
- SQLite 3.35.0+ support (for RETURNING clauses)

If tests fail with version mismatch errors:
1. Update Rust: `rustup update stable`
2. Reinstall Diesel CLI: `cargo install diesel_cli --no-default-features --features sqlite-bundled --force`
3. Verify versions match story requirements

---

## Contact

**Questions or Issues?**

- Ask in team standup
- Tag @TEA in Slack/Discord
- Refer to `_bmad/bmm/docs/tea-README.md` for workflow documentation
- Consult `_bmad/bmm/testarch/knowledge/` for testing best practices
- Review story file: `_bmad-output/implementation-artifacts/1-2-set-up-sqlite-database-with-diesel-orm.md`

---

**Generated by BMad TEA Agent** - 2026-01-19
